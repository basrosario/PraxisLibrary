{
  "version": 1,
  "generated": "2026-02-16T18:32:25Z",
  "techniqueCount": 175,
  "categories": {
    "structured": "Structured Frameworks",
    "reasoning": "Reasoning & CoT",
    "decomposition": "Decomposition",
    "self-correction": "Self-Correction",
    "icl": "In-Context Learning",
    "ensemble": "Ensemble Methods",
    "strategies": "Prompting Strategies",
    "code": "Code",
    "safety": "Safety & Alignment",
    "community": "Community Frameworks",
    "image": "Image Prompting",
    "audio": "Audio Prompting",
    "video": "Video Prompting",
    "3d": "3D / Spatial"
  },
  "techniques": [
    {
      "id": "costar",
      "name": "COSTAR",
      "fullName": "COSTAR Method",
      "url": "learn/costar.html",
      "category": "structured",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "costar",
        "method",
        "framework",
        "professional",
        "content creation",
        "audience"
      ],
      "bestFor": "Context, Objective, Style, Tone, Audience, Response. Ideal for professional content creation with specific voice and audience requirements."
    },
    {
      "id": "crisp",
      "name": "CRISP",
      "fullName": "CRISP Method",
      "url": "learn/crisp.html",
      "category": "structured",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "crisp",
        "method",
        "framework",
        "context",
        "role",
        "instructions",
        "specifics",
        "parameters"
      ],
      "bestFor": "Context, Role, Instructions, Specifics, Parameters. The essential framework for clear, effective prompts."
    },
    {
      "id": "crispe",
      "name": "CRISPE",
      "fullName": "CRISPE Method",
      "url": "learn/crispe.html",
      "category": "structured",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "crispe",
        "method",
        "framework",
        "example",
        "few-shot",
        "creative"
      ],
      "bestFor": "CRISP plus Example for few-shot learning. Particularly useful for creative tasks where showing is better than telling."
    },
    {
      "id": "constrained-output",
      "name": "Constrained Output",
      "fullName": "Constrained Output Framework",
      "url": "learn/constrained-output.html",
      "category": "structured",
      "useCases": [
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "constrained output",
        "format",
        "structured",
        "json",
        "template",
        "framework"
      ],
      "bestFor": "Define exact output formats, lengths, and structures. Essential for integrating AI outputs into workflows."
    },
    {
      "id": "context-structure",
      "name": "Context Structure",
      "fullName": "Context Structure",
      "url": "learn/context-structure.html",
      "category": "structured",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "context",
        "structure",
        "learn",
        "organizing",
        "ordering",
        "delimiting",
        "information",
        "prompts",
        "dramatically",
        "affects",
        "llm",
        "comprehension"
      ],
      "bestFor": "Context Structure: Learn how organizing, ordering, and delimiting information in prompts dramatically affects LLM comprehension, accuracy, and output quality."
    },
    {
      "id": "active-prompting",
      "name": "Active",
      "fullName": "Active Prompting",
      "url": "learn/active-prompting.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "active",
        "prompting",
        "identify",
        "model",
        "uncertain",
        "questions",
        "focus",
        "chain-of-thought",
        "annotation",
        "effort",
        "matters",
        "improved"
      ],
      "bestFor": "Active Prompting: Identify the model's most uncertain questions and focus chain-of-thought annotation effort where it matters most for improved reasoning performance."
    },
    {
      "id": "algorithm-of-thoughts",
      "name": "Algorithm of Thoughts (AoT)",
      "fullName": "Algorithm of Thoughts (AoT)",
      "url": "learn/algorithm-of-thoughts.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "algorithm of thoughts",
        "aot",
        "depth-first search",
        "breadth-first search",
        "dfs",
        "bfs",
        "single-call",
        "solution space",
        "algorithmic reasoning",
        "tree search"
      ],
      "bestFor": "Algorithm of Thoughts (AoT): Embed algorithmic thinking patterns like DFS and BFS directly into prompts for efficient, structured solution-space exploration in a single inference call."
    },
    {
      "id": "analogical-reasoning",
      "name": "Analogical Reasoning",
      "fullName": "Analogical Reasoning",
      "url": "learn/analogical-reasoning.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving",
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "analogical",
        "reasoning",
        "self-generate",
        "relevant",
        "examples",
        "analogies",
        "training",
        "solve",
        "novel",
        "problems",
        "manual",
        "demonstrations"
      ],
      "bestFor": "Analogical Reasoning: Have the AI self-generate relevant examples and analogies from its training to solve novel problems — no manual demonstrations needed."
    },
    {
      "id": "auto-cot",
      "name": "Auto-CoT",
      "fullName": "Auto-CoT",
      "url": "learn/auto-cot.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "auto-cot",
        "automatically",
        "generate",
        "diverse",
        "chain-of-thought",
        "demonstrations",
        "question",
        "clustering",
        "manual",
        "examples",
        "needed",
        "reasoning"
      ],
      "bestFor": "Auto-CoT: Automatically generate diverse Chain-of-Thought demonstrations through question clustering — no manual examples needed."
    },
    {
      "id": "buffer-of-thoughts",
      "name": "Buffer of Thoughts (BoT)",
      "fullName": "Buffer of Thoughts (BoT)",
      "url": "learn/buffer-of-thoughts.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving",
        "planning"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "buffer of thoughts",
        "bot",
        "thought templates",
        "meta-buffer",
        "reasoning memory",
        "template-guided",
        "reusable reasoning",
        "meta-reasoning"
      ],
      "bestFor": "Buffer of Thoughts (BoT): Maintain reusable thought-templates from past problem-solving, achieving 11-51% improvements on reasoning benchmarks through template-guided reasoning."
    },
    {
      "id": "chain-of-abstraction",
      "name": "Chain of Abstraction (CoA)",
      "fullName": "Chain of Abstraction (CoA)",
      "url": "learn/chain-of-abstraction.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving",
        "math"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "chain of abstraction",
        "coa",
        "abstract placeholders",
        "parallel tool calling",
        "tool use",
        "separation of concerns",
        "concretization",
        "multi-tool"
      ],
      "bestFor": "Chain of Abstraction: Reason with abstract placeholders first, then fill in concrete values using domain tools for cleaner reasoning and parallel execution."
    },
    {
      "id": "chain-of-knowledge",
      "name": "Chain of Knowledge (CoK)",
      "fullName": "Chain of Knowledge (CoK)",
      "url": "learn/chain-of-knowledge.html",
      "category": "reasoning",
      "useCases": [
        "research",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "chain of knowledge",
        "cok",
        "knowledge triples",
        "evidence triples",
        "subject-relation-object",
        "structured evidence",
        "knowledge graph",
        "verifiable"
      ],
      "bestFor": "Chain of Knowledge: Generate structured evidence triples with explanation hints for transparent, verifiable reasoning that reduces logical errors."
    },
    {
      "id": "chain-of-symbol",
      "name": "Chain-of-Symbol Prompting (CoS)",
      "fullName": "Chain-of-Symbol Prompting (CoS)",
      "url": "learn/chain-of-symbol.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "chain-of-symbol",
        "cos",
        "symbolic",
        "spatial reasoning",
        "structural",
        "compact notation",
        "arrows",
        "coordinates"
      ],
      "bestFor": "Chain-of-Symbol: Replace natural language with compact symbolic representations for spatial and structural reasoning, improving accuracy by up to 60%."
    },
    {
      "id": "chain-of-thought",
      "name": "Chain-of-Thought",
      "fullName": "Chain-of-Thought Framework",
      "url": "learn/chain-of-thought.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "chain of thought",
        "step by step",
        "reasoning",
        "think through",
        "cot",
        "framework"
      ],
      "bestFor": "Encourage AI to think step-by-step through complex problems. Improves accuracy for math, logic, and analysis."
    },
    {
      "id": "complexity-prompting",
      "name": "Complexity-Based",
      "fullName": "Complexity-Based Prompting",
      "url": "learn/complexity-prompting.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "complexity-based",
        "prompting",
        "enhance",
        "self-consistency",
        "weighting",
        "reasoning",
        "chains",
        "complexity",
        "longer",
        "thorough",
        "get",
        "influence"
      ],
      "bestFor": "Complexity-Based Prompting: Enhance Self-Consistency by weighting reasoning chains by their complexity — longer, more thorough chains get more influence."
    },
    {
      "id": "contrastive-cot",
      "name": "Contrastive Chain-of-Thought",
      "fullName": "Contrastive Chain-of-Thought",
      "url": "learn/contrastive-cot.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "contrastive",
        "chain-of-thought",
        "show",
        "correct",
        "incorrect",
        "reasoning",
        "help",
        "distinguish",
        "good",
        "bad",
        "patterns",
        "cot"
      ],
      "bestFor": "Contrastive Chain-of-Thought: Show both correct and incorrect reasoning to help AI distinguish good from bad reasoning patterns."
    },
    {
      "id": "dual-process-prompting",
      "name": "Dual Process",
      "fullName": "Dual Process Prompting",
      "url": "learn/dual-process-prompting.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "dual process",
        "system 1",
        "system 2",
        "kahneman",
        "fast thinking",
        "slow thinking",
        "complexity routing",
        "efficiency"
      ],
      "bestFor": "Dual Process Prompting: Route between fast intuitive responses and slow deliberate reasoning based on task complexity, inspired by cognitive science."
    },
    {
      "id": "everything-of-thoughts",
      "name": "Everything of Thoughts (XoT)",
      "fullName": "Everything of Thoughts (XoT)",
      "url": "learn/everything-of-thoughts.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving",
        "math"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "everything of thoughts",
        "xot",
        "monte carlo tree search",
        "mcts",
        "reinforcement learning",
        "unified reasoning",
        "penrose triangle",
        "microsoft research"
      ],
      "bestFor": "Everything of Thoughts (XoT): Combine reinforcement learning and Monte Carlo Tree Search for flexible, efficient reasoning that resolves the performance-efficiency-flexibility trilemma."
    },
    {
      "id": "faithful-cot",
      "name": "Faithful Chain-of-Thought",
      "fullName": "Faithful Chain-of-Thought",
      "url": "learn/faithful-cot.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "faithful",
        "chain-of-thought",
        "ground",
        "reasoning",
        "step",
        "verifiable",
        "logic",
        "using",
        "symbolic",
        "computation",
        "ensure",
        "chain"
      ],
      "bestFor": "Faithful Chain-of-Thought: Ground every reasoning step in verifiable logic using symbolic computation to ensure the chain actually determines the answer."
    },
    {
      "id": "maieutic-prompting",
      "name": "Maieutic",
      "fullName": "Maieutic Prompting",
      "url": "learn/maieutic-prompting.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "maieutic",
        "socratic",
        "explanation tree",
        "recursive explanations",
        "satisfiability",
        "logical consistency",
        "commonsense reasoning",
        "verification"
      ],
      "bestFor": "Maieutic Prompting: Build a tree of recursive explanations and use logical consistency to extract reliable commonsense reasoning from language models."
    },
    {
      "id": "memory-of-thought",
      "name": "Memory of Thought",
      "fullName": "Memory of Thought",
      "url": "learn/memory-of-thought.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "memory",
        "thought",
        "store",
        "model",
        "successful",
        "reasoning",
        "chains",
        "retrieve",
        "demonstrations",
        "new",
        "problems",
        "turning"
      ],
      "bestFor": "Memory of Thought: Store the model's own successful reasoning chains and retrieve them as demonstrations for new problems — turning past performance into future guidance."
    },
    {
      "id": "reversing-cot",
      "name": "Reversing Chain-of-Thought",
      "fullName": "Reversing Chain-of-Thought",
      "url": "learn/reversing-cot.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving",
        "math"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "reversing",
        "chain-of-thought",
        "verify",
        "forward",
        "reasoning",
        "working",
        "backwards",
        "conclusion",
        "premises",
        "catching",
        "errors",
        "forward-only"
      ],
      "bestFor": "Reversing Chain-of-Thought: Verify forward reasoning by working backwards from conclusion to premises, catching errors that forward-only reasoning misses."
    },
    {
      "id": "scratchpad-prompting",
      "name": "Scratchpad",
      "fullName": "Scratchpad Prompting",
      "url": "learn/scratchpad-prompting.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "coding"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "scratchpad",
        "intermediate steps",
        "show work",
        "computation",
        "workspace",
        "code tracing",
        "step-by-step",
        "arithmetic"
      ],
      "bestFor": "Scratchpad Prompting: Instruct AI models to show intermediate computation steps in a dedicated workspace before producing final answers, improving accuracy on multi-step problems."
    },
    {
      "id": "selection-inference",
      "name": "Selection-Inference (SI)",
      "fullName": "Selection-Inference (SI)",
      "url": "learn/selection-inference.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "selection-inference",
        "si",
        "premise selection",
        "logical reasoning",
        "two-module",
        "alternating",
        "deduction",
        "evidence selection"
      ],
      "bestFor": "Selection-Inference: Alternate between selecting relevant premises and drawing conclusions to achieve structured, auditable logical reasoning."
    },
    {
      "id": "step-back",
      "name": "Step-Back",
      "fullName": "Step-Back Prompting",
      "url": "learn/step-back.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "step-back",
        "prompting",
        "abstract",
        "high-level",
        "principles",
        "answering",
        "specific",
        "questions",
        "grounding",
        "responses",
        "foundational",
        "knowledge"
      ],
      "bestFor": "Step-Back Prompting: Abstract to high-level principles before answering specific questions — grounding responses in foundational knowledge for better reasoning."
    },
    {
      "id": "structured-cot",
      "name": "Structured Chain-of-Thought",
      "fullName": "Structured Chain-of-Thought",
      "url": "learn/structured-cot.html",
      "category": "reasoning",
      "useCases": [
        "structured-output",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "structured",
        "chain-of-thought",
        "enforce",
        "specific",
        "reasoning",
        "templates",
        "formats",
        "consistent",
        "verifiable",
        "outputs",
        "cot"
      ],
      "bestFor": "Structured Chain-of-Thought: Enforce specific reasoning templates and formats for consistent, verifiable AI outputs."
    },
    {
      "id": "symbolic-cot",
      "name": "Symbolic Chain-of-Thought (SymbCoT)",
      "fullName": "Symbolic Chain-of-Thought (SymbCoT)",
      "url": "learn/symbolic-cot.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "symbolic cot",
        "symbcot",
        "formal logic",
        "first-order logic",
        "propositional",
        "verifiable reasoning",
        "logic rules",
        "proof"
      ],
      "bestFor": "Symbolic CoT: Integrate formal logic rules and symbolic expressions with natural language reasoning for verifiable, rigorous chain-of-thought inference."
    },
    {
      "id": "tab-cot",
      "name": "Tab-CoT (Tabular Chain-of-Thought)",
      "fullName": "Tab-CoT (Tabular Chain-of-Thought)",
      "url": "learn/tab-cot.html",
      "category": "reasoning",
      "useCases": [
        "structured-output",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "tab-cot",
        "tabular",
        "chain-of-thought",
        "format",
        "reasoning",
        "structured",
        "tables",
        "explicit",
        "columns",
        "step",
        "operation",
        "input"
      ],
      "bestFor": "Tab-CoT (Tabular Chain-of-Thought): Format AI reasoning into structured tables with explicit columns for step, operation, input, output, and reasoning."
    },
    {
      "id": "thought-propagation",
      "name": "Thought Propagation",
      "fullName": "Thought Propagation",
      "url": "learn/thought-propagation.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving",
        "planning"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "thought propagation",
        "analogous problems",
        "analogy",
        "insight transfer",
        "cross-domain",
        "problem solving",
        "meta-reasoning",
        "refinement"
      ],
      "bestFor": "Thought Propagation: Solve analogous problems first, then propagate insights and solutions to refine the answer to the target problem."
    },
    {
      "id": "thread-of-thought",
      "name": "Thread of Thought",
      "fullName": "Thread of Thought",
      "url": "learn/thread-of-thought.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "thread",
        "thought",
        "thot",
        "guide",
        "chaotic",
        "lengthy",
        "contexts",
        "walking",
        "information",
        "systematically",
        "answering",
        "taming"
      ],
      "bestFor": "Thread of Thought (ThoT): Guide AI through chaotic, lengthy contexts by walking through the information systematically before answering — taming information overload."
    },
    {
      "id": "uncertainty-cot",
      "name": "Uncertainty-Routed CoT",
      "fullName": "Uncertainty-Routed CoT",
      "url": "learn/uncertainty-cot.html",
      "category": "reasoning",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "uncertainty",
        "routed",
        "chain-of-thought",
        "confidence",
        "cost optimization",
        "selective reasoning",
        "triage",
        "conditional"
      ],
      "bestFor": "Conditionally apply chain-of-thought reasoning only when the model is uncertain, saving tokens on easy questions while maintaining accuracy on hard ones."
    },
    {
      "id": "zero-shot-cot",
      "name": "Zero-Shot Chain-of-Thought",
      "fullName": "Zero-Shot Chain-of-Thought",
      "url": "learn/zero-shot-cot.html",
      "category": "reasoning",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "zero-shot",
        "chain-of-thought",
        "unlock",
        "reasoning",
        "simple",
        "trigger",
        "phrase",
        "add",
        "let",
        "think",
        "step",
        "prompt"
      ],
      "bestFor": "Zero-Shot Chain-of-Thought: Unlock AI reasoning with a simple trigger phrase. Add 'Let's think step by step' to any prompt for dramatically improved accuracy without examples."
    },
    {
      "id": "branch-solve-merge",
      "name": "Branch-Solve-Merge (BSM)",
      "fullName": "Branch-Solve-Merge (BSM)",
      "url": "learn/branch-solve-merge.html",
      "category": "decomposition",
      "useCases": [
        "problem-solving",
        "planning"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "branch-solve-merge",
        "bsm",
        "parallel decomposition",
        "merge",
        "independent branches",
        "concurrent"
      ],
      "bestFor": "Branch-Solve-Merge: Decompose complex tasks into parallel branches, solve each independently, then merge results into a coherent final answer."
    },
    {
      "id": "chain-of-table",
      "name": "Chain of Table",
      "fullName": "Chain of Table",
      "url": "learn/chain-of-table.html",
      "category": "decomposition",
      "useCases": [
        "structured-output",
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "chain of table",
        "tabular",
        "table operations",
        "filter",
        "sort",
        "aggregate",
        "data reasoning"
      ],
      "bestFor": "Chain of Table: Transform and reason over tabular data through step-by-step table operations for verifiable data analysis."
    },
    {
      "id": "decomp",
      "name": "Decomposed Prompting (DecomP)",
      "fullName": "Decomposed Prompting (DecomP)",
      "url": "learn/decomp.html",
      "category": "decomposition",
      "useCases": [
        "problem-solving",
        "planning"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "decomposed",
        "prompting",
        "decomp",
        "break",
        "complex",
        "tasks",
        "specialized",
        "sub-procedures",
        "routing",
        "sub-problem",
        "ideal",
        "solver"
      ],
      "bestFor": "Decomposed Prompting (DecomP): Break complex tasks into specialized sub-procedures, routing each sub-problem to its ideal solver for maximum accuracy."
    },
    {
      "id": "graph-of-thought",
      "name": "Graph of Thoughts",
      "fullName": "Graph of Thoughts",
      "url": "learn/graph-of-thought.html",
      "category": "decomposition",
      "useCases": [
        "problem-solving",
        "planning"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "graph",
        "thoughts",
        "got",
        "model",
        "reasoning",
        "structure",
        "branch",
        "merge",
        "loop",
        "form",
        "complex",
        "networks",
        "framework"
      ],
      "bestFor": "Graph of Thoughts (GoT): Model reasoning as a graph structure where thoughts can branch, merge, loop, and form complex networks for superior problem-solving."
    },
    {
      "id": "least-to-most",
      "name": "Least-to-Most",
      "fullName": "Least-to-Most Prompting",
      "url": "learn/least-to-most.html",
      "category": "decomposition",
      "useCases": [
        "math",
        "problem-solving",
        "planning"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "least-to-most",
        "prompting",
        "break",
        "complex",
        "problems",
        "simpler",
        "sub-problems",
        "solve",
        "progressively",
        "easiest",
        "hardest",
        "build"
      ],
      "bestFor": "Least-to-Most Prompting: Break complex problems into simpler sub-problems, solve them progressively from easiest to hardest, and build toward the final answer systematically."
    },
    {
      "id": "plan-and-solve",
      "name": "Plan-and-Solve",
      "fullName": "Plan-and-Solve Prompting",
      "url": "learn/plan-and-solve.html",
      "category": "decomposition",
      "useCases": [
        "planning",
        "math",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "plan-and-solve",
        "prompting",
        "two-phase",
        "zero-shot",
        "technique",
        "first",
        "devises",
        "plan",
        "executes",
        "step",
        "improved",
        "multi-step"
      ],
      "bestFor": "Plan-and-Solve Prompting: A two-phase zero-shot technique that first devises a plan then executes it step by step for improved multi-step reasoning."
    },
    {
      "id": "program-of-thought",
      "name": "Program of Thoughts (PoT)",
      "fullName": "Program of Thoughts (PoT)",
      "url": "learn/program-of-thought.html",
      "category": "decomposition",
      "useCases": [
        "math",
        "coding"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "program",
        "thoughts",
        "pot",
        "instead",
        "reasoning",
        "natural",
        "language",
        "generate",
        "executable",
        "code",
        "represents",
        "steps"
      ],
      "bestFor": "Program of Thoughts (PoT): Instead of reasoning in natural language, generate executable code that represents the reasoning steps. A code interpreter then runs the program to produce exact answers."
    },
    {
      "id": "recursion-of-thought",
      "name": "Recursion of Thought",
      "fullName": "Recursion of Thought",
      "url": "learn/recursion-of-thought.html",
      "category": "decomposition",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "recursion",
        "thought",
        "apply",
        "recursive",
        "divide-and-conquer",
        "reasoning",
        "decompose",
        "complex",
        "problems",
        "sub-problems",
        "reaching",
        "solvable"
      ],
      "bestFor": "Recursion of Thought: Apply recursive divide-and-conquer reasoning to decompose complex problems into sub-problems until reaching solvable base cases."
    },
    {
      "id": "skeleton-of-thought",
      "name": "Skeleton-of-Thought",
      "fullName": "Skeleton-of-Thought",
      "url": "learn/skeleton-of-thought.html",
      "category": "decomposition",
      "useCases": [
        "writing",
        "planning"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "skeleton-of-thought",
        "parallel generation",
        "outline first",
        "latency reduction",
        "structured output",
        "parallel decoding",
        "speed optimization",
        "decomposition",
        "expand in parallel",
        "response structure",
        "framework"
      ],
      "bestFor": "Skeleton-of-Thought: Accelerate AI responses by generating an answer outline first, then expanding each point in parallel for faster, more structured outputs."
    },
    {
      "id": "successive-prompting",
      "name": "Successive",
      "fullName": "Successive Prompting",
      "url": "learn/successive-prompting.html",
      "category": "decomposition",
      "useCases": [
        "problem-solving",
        "planning"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "successive",
        "sequential",
        "sub-questions",
        "multi-turn",
        "decomposition",
        "iterative"
      ],
      "bestFor": "Successive Prompting: Decompose complex questions into a sequence of simpler sub-questions, answering each before proceeding to the next."
    },
    {
      "id": "tree-of-thought",
      "name": "Tree of Thought",
      "fullName": "Tree of Thought",
      "url": "learn/tree-of-thought.html",
      "category": "decomposition",
      "useCases": [
        "problem-solving",
        "planning",
        "creative"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "tree",
        "thought",
        "explore",
        "multiple",
        "reasoning",
        "paths",
        "structure",
        "evaluate",
        "branches",
        "prune",
        "dead",
        "ends",
        "framework"
      ],
      "bestFor": "Tree of Thought: Explore multiple reasoning paths as a tree structure, evaluate branches, and prune dead ends for complex problem-solving with LLMs."
    },
    {
      "id": "critic",
      "name": "CRITIC",
      "fullName": "CRITIC",
      "url": "learn/critic.html",
      "category": "self-correction",
      "useCases": [
        "writing",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "critic",
        "llms",
        "critique",
        "verify",
        "outputs",
        "using",
        "external",
        "tools",
        "structured",
        "feedback",
        "self-correction"
      ],
      "bestFor": "CRITIC: Have LLMs critique and verify their own outputs using external tools and structured feedback."
    },
    {
      "id": "chain-of-verification",
      "name": "Chain-of-Verification",
      "fullName": "Chain-of-Verification",
      "url": "learn/chain-of-verification.html",
      "category": "self-correction",
      "useCases": [
        "research",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "chain-of-verification",
        "generate",
        "answers",
        "create",
        "verification",
        "questions",
        "answer",
        "revise",
        "based",
        "discovered",
        "inconsistencies",
        "reasoning"
      ],
      "bestFor": "Chain-of-Verification: Generate answers, create verification questions, answer them, and revise based on discovered inconsistencies."
    },
    {
      "id": "cumulative-reasoning",
      "name": "Cumulative Reasoning",
      "fullName": "Cumulative Reasoning",
      "url": "learn/cumulative-reasoning.html",
      "category": "self-correction",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "cumulative",
        "reasoning",
        "build",
        "answers",
        "one",
        "verified",
        "proposition",
        "time",
        "using",
        "three-module",
        "architecture",
        "proposer"
      ],
      "bestFor": "Cumulative Reasoning: Build answers one verified proposition at a time using a three-module architecture of Proposer, Verifier, and Reporter."
    },
    {
      "id": "progressive-hint",
      "name": "Progressive-Hint Prompting (PHP)",
      "fullName": "Progressive-Hint Prompting (PHP)",
      "url": "learn/progressive-hint.html",
      "category": "self-correction",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "progressive-hint",
        "php",
        "iterative refinement",
        "hints",
        "convergence",
        "self-guided",
        "math reasoning"
      ],
      "bestFor": "Progressive-Hint Prompting: Iteratively provide the model with its own previous answers as hints, refining toward the correct solution."
    },
    {
      "id": "quiet-star",
      "name": "Quiet-STaR",
      "fullName": "Quiet-STaR",
      "url": "learn/quiet-star.html",
      "category": "self-correction",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "quiet-star",
        "internal reasoning",
        "inner speech",
        "token-level",
        "metacognition",
        "learned thinking"
      ],
      "bestFor": "Quiet-STaR: Train language models to generate internal reasoning at every token, learning to think before speaking for improved prediction."
    },
    {
      "id": "reflexion",
      "name": "Reflexion",
      "fullName": "Reflexion",
      "url": "learn/reflexion.html",
      "category": "self-correction",
      "useCases": [
        "coding",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "reflexion",
        "learn",
        "failures",
        "reflecting",
        "mistakes",
        "storing",
        "insights",
        "memory",
        "future",
        "attempts",
        "self-correction",
        "framework"
      ],
      "bestFor": "Reflexion: Learn from failures by reflecting on mistakes and storing insights in memory for future attempts."
    },
    {
      "id": "star",
      "name": "STaR (Self-Taught Reasoner)",
      "fullName": "STaR (Self-Taught Reasoner)",
      "url": "learn/star.html",
      "category": "self-correction",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "star",
        "self-taught reasoner",
        "bootstrap",
        "self-improvement",
        "rationale generation",
        "fine-tuning"
      ],
      "bestFor": "STaR: Bootstrap reasoning ability by iteratively generating rationales, filtering for correct ones, and fine-tuning on successful reasoning chains."
    },
    {
      "id": "self-calibration",
      "name": "Self-Calibration",
      "fullName": "Self-Calibration",
      "url": "learn/self-calibration.html",
      "category": "self-correction",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "self-calibration",
        "model",
        "assess",
        "confidence",
        "know",
        "trust",
        "answers",
        "self-correction"
      ],
      "bestFor": "Self-Calibration: Have the model assess its own confidence to know when to trust its answers."
    },
    {
      "id": "self-refine",
      "name": "Self-Refine",
      "fullName": "Self-Refine",
      "url": "learn/self-refine.html",
      "category": "self-correction",
      "useCases": [
        "writing",
        "coding",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "self-refine",
        "iterative",
        "improvement",
        "generates",
        "critiques",
        "refines",
        "outputs",
        "higher",
        "quality",
        "results",
        "self-correction"
      ],
      "bestFor": "Self-Refine: Iterative improvement where AI generates, critiques, and refines its own outputs for higher quality results."
    },
    {
      "id": "self-verification",
      "name": "Self-Verification",
      "fullName": "Self-Verification",
      "url": "learn/self-verification.html",
      "category": "self-correction",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "self-verification",
        "validate",
        "answers",
        "systematic",
        "checking",
        "backward",
        "reasoning",
        "constraint",
        "validation",
        "self-correction"
      ],
      "bestFor": "Self-Verification: Have AI validate its own answers through systematic checking, backward reasoning, and constraint validation."
    },
    {
      "id": "verify-and-edit",
      "name": "Verify-and-Edit",
      "fullName": "Verify-and-Edit",
      "url": "learn/verify-and-edit.html",
      "category": "self-correction",
      "useCases": [
        "research",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "verify-and-edit",
        "verification",
        "fact-checking",
        "error correction",
        "post-generation",
        "editing"
      ],
      "bestFor": "Verify-and-Edit: Generate an initial answer, verify each reasoning step, then edit the chain to fix mistakes before the final answer."
    },
    {
      "id": "active-example",
      "name": "Active Example Selection",
      "fullName": "Active Example Selection",
      "url": "learn/active-example.html",
      "category": "icl",
      "useCases": [
        "coding",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "active example",
        "active learning",
        "uncertainty",
        "dynamic selection",
        "query-aware",
        "targeted demonstrations",
        "confidence",
        "adaptive"
      ],
      "bestFor": "Dynamically choose few-shot demonstrations based on model uncertainty for each specific query, providing targeted examples where the model needs them most."
    },
    {
      "id": "demo-ensembling",
      "name": "Demonstration Ensembling",
      "fullName": "Demonstration Ensembling",
      "url": "learn/demo-ensembling.html",
      "category": "icl",
      "useCases": [
        "problem-solving",
        "coding"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "demonstration",
        "ensembling",
        "run",
        "query",
        "multiple",
        "different",
        "sets",
        "few-shot",
        "examples",
        "combine",
        "results",
        "voting"
      ],
      "bestFor": "Demonstration Ensembling: Run the same query with multiple different sets of few-shot examples and combine results through voting or aggregation for more robust, consistent AI predictions."
    },
    {
      "id": "example-ordering",
      "name": "Example Ordering",
      "fullName": "Example Ordering",
      "url": "learn/example-ordering.html",
      "category": "icl",
      "useCases": [
        "coding",
        "structured-output"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "example ordering",
        "permutation",
        "recency bias",
        "majority label bias",
        "few-shot",
        "demonstration order",
        "sequence",
        "arrangement"
      ],
      "bestFor": "Optimize the sequence of few-shot demonstrations to maximize model performance. The same examples in different orders can swing accuracy by 20+ percentage points."
    },
    {
      "id": "example-selection",
      "name": "Example Selection",
      "fullName": "Example Selection",
      "url": "learn/example-selection.html",
      "category": "icl",
      "useCases": [
        "coding",
        "structured-output"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "example",
        "selection",
        "learn",
        "choosing",
        "right",
        "few-shot",
        "demonstrations",
        "improve",
        "performance",
        "over",
        "random",
        "similarity-based"
      ],
      "bestFor": "Example Selection: Learn how choosing the right few-shot demonstrations can improve AI performance by 20-30% over random selection through similarity-based, diversity-based, and task-specific strategies."
    },
    {
      "id": "few-shot-learning",
      "name": "Few-Shot Learning",
      "fullName": "Few-Shot Learning Framework",
      "url": "learn/few-shot-learning.html",
      "category": "icl",
      "useCases": [
        "writing",
        "coding",
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "few-shot",
        "examples",
        "demonstrations",
        "pattern matching",
        "framework"
      ],
      "bestFor": "Provide 2-5 examples to help AI understand the pattern you want. More effective than description for complex formats."
    },
    {
      "id": "knn-prompting",
      "name": "KNN",
      "fullName": "KNN Prompting",
      "url": "learn/knn-prompting.html",
      "category": "icl",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "knn",
        "prompting",
        "dynamically",
        "select",
        "relevant",
        "few-shot",
        "examples",
        "using",
        "nearest-neighbor",
        "retrieval",
        "improved",
        "in-context"
      ],
      "bestFor": "KNN Prompting: Dynamically select the most relevant few-shot examples using nearest-neighbor retrieval for improved in-context learning performance."
    },
    {
      "id": "many-shot",
      "name": "Many-Shot",
      "fullName": "Many-Shot Prompting",
      "url": "learn/many-shot.html",
      "category": "icl",
      "useCases": [
        "coding",
        "structured-output"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "many-shot",
        "in-context learning",
        "examples",
        "demonstrations",
        "large context",
        "hundreds",
        "pattern learning",
        "classification",
        "format consistency"
      ],
      "bestFor": "Provide dozens to thousands of demonstrations within the prompt, leveraging extended context windows to teach complex patterns through volume of examples."
    },
    {
      "id": "one-shot",
      "name": "One-Shot Learning",
      "fullName": "One-Shot Learning",
      "url": "learn/one-shot.html",
      "category": "icl",
      "useCases": [
        "writing",
        "coding"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "one-shot",
        "learning",
        "teach",
        "new",
        "tasks",
        "single",
        "example",
        "sweet",
        "spot",
        "zero-shot",
        "few-shot",
        "prompting"
      ],
      "bestFor": "One-Shot Learning: Teach AI new tasks with a single example. The sweet spot between zero-shot and few-shot prompting for efficient, format-accurate responses."
    },
    {
      "id": "prompt-mining",
      "name": "Prompt Mining",
      "fullName": "Prompt Mining",
      "url": "learn/prompt-mining.html",
      "category": "icl",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "prompt",
        "mining",
        "automatically",
        "discover",
        "effective",
        "templates",
        "systematically",
        "searching",
        "candidate",
        "phrasings",
        "evaluating",
        "performance"
      ],
      "bestFor": "Prompt Mining: Automatically discover effective prompt templates by systematically searching through candidate phrasings, evaluating performance, and surfacing optimal formulations that humans would never think to try."
    },
    {
      "id": "self-generated-icl",
      "name": "Self-Generated ICL",
      "fullName": "Self-Generated ICL",
      "url": "learn/self-generated-icl.html",
      "category": "icl",
      "useCases": [
        "problem-solving",
        "coding"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "self-generated",
        "in-context learning",
        "bootstrap",
        "auto-generate",
        "demonstrations",
        "cold start",
        "no labeled data",
        "self-teaching"
      ],
      "bestFor": "Have the model generate its own few-shot examples before tackling the actual task, eliminating the need for manually curated demonstrations."
    },
    {
      "id": "vote-k",
      "name": "Vote-K",
      "fullName": "Vote-K Prompting",
      "url": "learn/vote-k.html",
      "category": "icl",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "vote-k",
        "prompting",
        "let",
        "model",
        "vote",
        "unlabeled",
        "examples",
        "valuable",
        "annotate",
        "focusing",
        "human",
        "effort"
      ],
      "bestFor": "Vote-K Prompting: Let the model vote on which unlabeled examples would be most valuable to annotate, focusing human effort on the most impactful demonstrations."
    },
    {
      "id": "zero-shot",
      "name": "Zero-Shot",
      "fullName": "Zero-Shot Prompting",
      "url": "learn/zero-shot.html",
      "category": "icl",
      "useCases": [
        "writing",
        "problem-solving"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "zero-shot",
        "prompting",
        "foundational",
        "technique",
        "getting",
        "perform",
        "tasks",
        "without",
        "examples",
        "relying",
        "entirely",
        "clear"
      ],
      "bestFor": "Zero-Shot Prompting: The foundational technique for getting AI to perform tasks without any examples, relying entirely on clear instructions and pre-trained knowledge."
    },
    {
      "id": "cosp",
      "name": "COSP",
      "fullName": "COSP",
      "url": "learn/cosp.html",
      "category": "ensemble",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "cosp",
        "consistency-based",
        "self-adaptive",
        "prompting",
        "automatically",
        "generate",
        "reliable",
        "demonstrations",
        "model",
        "consistent",
        "outputs",
        "without"
      ],
      "bestFor": "COSP: Consistency-based Self-adaptive Prompting — automatically generate reliable demonstrations from the model's own consistent outputs without human labeling."
    },
    {
      "id": "debate-prompting",
      "name": "Debate",
      "fullName": "Debate Prompting",
      "url": "learn/debate-prompting.html",
      "category": "ensemble",
      "useCases": [
        "research",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "debate",
        "adversarial",
        "opposing positions",
        "argumentation",
        "judge",
        "pro con"
      ],
      "bestFor": "Debate Prompting: Have agents argue opposing positions, then judge the debate to extract the most well-supported answer."
    },
    {
      "id": "dense-prompting",
      "name": "Dense",
      "fullName": "Dense Prompting",
      "url": "learn/dense-prompting.html",
      "category": "ensemble",
      "useCases": [
        "writing",
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "dense",
        "prompting",
        "learn",
        "comprehensive",
        "information-rich",
        "prompts",
        "structured",
        "context",
        "constraints",
        "examples",
        "quality",
        "criteria"
      ],
      "bestFor": "Dense Prompting: Learn how comprehensive, information-rich prompts with structured context, constraints, examples, and quality criteria reduce ambiguity and improve AI output quality."
    },
    {
      "id": "diverse-prompting",
      "name": "DiVeRSe",
      "fullName": "DiVeRSe Prompting",
      "url": "learn/diverse-prompting.html",
      "category": "ensemble",
      "useCases": [
        "creative",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "diverse",
        "prompting",
        "combine",
        "reasoning",
        "paths",
        "step-by-step",
        "verification",
        "scoring",
        "produce",
        "reliable",
        "answers",
        "verified"
      ],
      "bestFor": "DiVeRSe Prompting: Combine diverse reasoning paths with step-by-step verification scoring to produce more reliable answers through verified ensemble voting."
    },
    {
      "id": "exchange-of-thought",
      "name": "Exchange-of-Thought (EoT)",
      "fullName": "Exchange-of-Thought (EoT)",
      "url": "learn/exchange-of-thought.html",
      "category": "ensemble",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "exchange-of-thought",
        "eot",
        "collaborative reasoning",
        "intermediate thoughts",
        "shared progress",
        "multi-agent"
      ],
      "bestFor": "Exchange-of-Thought: Multiple reasoning agents share intermediate thoughts for collaborative problem-solving."
    },
    {
      "id": "max-mutual-info",
      "name": "Max Mutual Information",
      "fullName": "Max Mutual Information",
      "url": "learn/max-mutual-info.html",
      "category": "ensemble",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "max",
        "mutual",
        "information",
        "select",
        "few-shot",
        "examples",
        "maximize",
        "connection",
        "demonstrations",
        "desired",
        "output",
        "choosing"
      ],
      "bestFor": "Max Mutual Information: Select few-shot examples that maximize the information connection between demonstrations and the desired output — choosing examples by predictive power, not surface similarity."
    },
    {
      "id": "meta-reasoning",
      "name": "Meta-Reasoning",
      "fullName": "Meta-Reasoning Prompting",
      "url": "learn/meta-reasoning.html",
      "category": "ensemble",
      "useCases": [
        "problem-solving",
        "planning"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "meta-reasoning",
        "prompting",
        "select",
        "best",
        "reasoning",
        "strategy",
        "problem",
        "solving",
        "matching",
        "technique",
        "task",
        "optimal"
      ],
      "bestFor": "Meta-Reasoning Prompting: Have the AI select the best reasoning strategy for each problem before solving it — matching technique to task for optimal results."
    },
    {
      "id": "mixture-of-experts",
      "name": "Mixture of Experts",
      "fullName": "Mixture of Experts Prompting",
      "url": "learn/mixture-of-experts.html",
      "category": "ensemble",
      "useCases": [
        "problem-solving",
        "coding"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "mixture of experts",
        "moe",
        "expert personas",
        "multi-perspective",
        "synthesis",
        "diverse expertise"
      ],
      "bestFor": "Mixture of Experts Prompting: Assign multiple expert personas to analyze a problem from diverse perspectives, then synthesize insights."
    },
    {
      "id": "multi-expert",
      "name": "Multi-Expert",
      "fullName": "Multi-Expert Prompting",
      "url": "learn/multi-expert.html",
      "category": "ensemble",
      "useCases": [
        "problem-solving",
        "writing"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "multi-expert",
        "panel",
        "deliberation",
        "voting",
        "consensus",
        "structured discussion"
      ],
      "bestFor": "Multi-Expert Prompting: Generate answers from multiple simulated experts with structured discussion and voting for higher accuracy."
    },
    {
      "id": "pairwise-evaluation",
      "name": "Pairwise Evaluation",
      "fullName": "Pairwise Evaluation",
      "url": "learn/pairwise-evaluation.html",
      "category": "ensemble",
      "useCases": [
        "writing",
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "pairwise",
        "evaluation",
        "comparison",
        "ranking",
        "relative",
        "elo",
        "llm-as-judge"
      ],
      "bestFor": "Pairwise Evaluation: Compare outputs in pairs for more consistent and reliable evaluation than absolute scoring."
    },
    {
      "id": "self-consistency",
      "name": "Self-Consistency",
      "fullName": "Self-Consistency Framework",
      "url": "learn/self-consistency.html",
      "category": "ensemble",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "self-consistency",
        "multiple answers",
        "verification",
        "accuracy",
        "framework"
      ],
      "bestFor": "Ask AI to solve problems multiple ways and compare. Helps catch errors and improve accuracy."
    },
    {
      "id": "universal-self-consistency",
      "name": "Universal Self-Consistency",
      "fullName": "Universal Self-Consistency",
      "url": "learn/universal-self-consistency.html",
      "category": "ensemble",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "universal",
        "self-consistency",
        "extend",
        "consistency-based",
        "voting",
        "beyond",
        "fixed",
        "answers",
        "free-form",
        "generation",
        "let",
        "model"
      ],
      "bestFor": "Universal Self-Consistency: Extend consistency-based voting beyond fixed answers to free-form generation — let the model itself judge which response best represents the consensus across multiple samples."
    },
    {
      "id": "ape",
      "name": "APE (Automatic Prompt Engineer)",
      "fullName": "APE (Automatic Prompt Engineer)",
      "url": "learn/ape.html",
      "category": "strategies",
      "useCases": [
        "coding",
        "structured-output"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "ape",
        "automatic prompt engineer",
        "prompt optimization",
        "llm search",
        "instruction generation"
      ],
      "bestFor": "APE: Automatically generate and select optimal prompt instructions via LLM-driven search."
    },
    {
      "id": "agentflow",
      "name": "AgentFlow",
      "fullName": "AgentFlow",
      "url": "learn/agentflow.html",
      "category": "strategies",
      "useCases": [
        "planning",
        "coding"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "agentflow",
        "flow-grpo",
        "multi-turn optimization",
        "credit assignment",
        "agentic systems",
        "trajectory rewards",
        "planner optimization",
        "reinforcement learning",
        "in-the-flow",
        "group policy optimization",
        "framework"
      ],
      "bestFor": "AgentFlow & Flow-GRPO: Optimize multi-turn agentic systems in-the-flow with group refined policy optimization for credit assignment across long trajectories."
    },
    {
      "id": "agentic-prompting",
      "name": "Agentic",
      "fullName": "Agentic Prompting",
      "url": "learn/agentic-prompting.html",
      "category": "strategies",
      "useCases": [
        "planning",
        "coding"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "agentic prompting",
        "ai agents",
        "autonomous",
        "tool use",
        "function calling",
        "planning",
        "multi-step",
        "goal-directed",
        "reasoning loop",
        "react pattern",
        "orchestration",
        "automation"
      ],
      "bestFor": "Agentic Prompting: Design AI systems that autonomously plan, execute, and adapt multi-step tasks using tools, memory, and reasoning loops."
    },
    {
      "id": "ask-me-anything",
      "name": "Ask Me Anything",
      "fullName": "Ask Me Anything Prompting",
      "url": "learn/ask-me-anything.html",
      "category": "strategies",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "ask me anything",
        "ama",
        "prompt reformulation",
        "qa format",
        "aggregation",
        "weak supervision"
      ],
      "bestFor": "Ask Me Anything: Transform task inputs into question-answer format and aggregate multiple reformulated responses."
    },
    {
      "id": "batch-prompting",
      "name": "Batch",
      "fullName": "Batch Prompting",
      "url": "learn/batch-prompting.html",
      "category": "strategies",
      "useCases": [
        "structured-output",
        "coding"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "batch prompting",
        "efficiency",
        "multiple tasks",
        "cost reduction",
        "parallel processing",
        "api optimization"
      ],
      "bestFor": "Batch Prompting: Process multiple task instances in a single prompt for efficiency and cost reduction."
    },
    {
      "id": "chain-of-density",
      "name": "Chain of Density",
      "fullName": "Chain of Density",
      "url": "learn/chain-of-density.html",
      "category": "strategies",
      "useCases": [
        "writing",
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "chain of density",
        "cod",
        "summarization",
        "entity-dense",
        "iterative refinement"
      ],
      "bestFor": "Chain of Density: Iteratively refine summaries to be progressively more entity-dense without increasing length."
    },
    {
      "id": "dspy",
      "name": "DSPy",
      "fullName": "DSPy",
      "url": "learn/dspy.html",
      "category": "strategies",
      "useCases": [
        "coding",
        "structured-output"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "dspy",
        "programming language models",
        "declarative",
        "compilation",
        "optimization",
        "signatures",
        "modules",
        "pipeline",
        "automatic prompting",
        "stanford nlp",
        "production",
        "framework"
      ],
      "bestFor": "DSPy: Program language models with typed signatures and automatic compilation instead of hand-crafted prompts. Build modular, optimizable AI pipelines."
    },
    {
      "id": "dialogue-guided",
      "name": "Dialogue-Guided",
      "fullName": "Dialogue-Guided Prompting",
      "url": "learn/dialogue-guided.html",
      "category": "strategies",
      "useCases": [
        "research",
        "writing"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "dialogue-guided",
        "multi-turn",
        "conversational",
        "role-based",
        "dialogue structure"
      ],
      "bestFor": "Dialogue-Guided Prompting: Use multi-turn dialogue structure to guide reasoning through conversational exchange."
    },
    {
      "id": "directional-stimulus",
      "name": "Directional Stimulus",
      "fullName": "Directional Stimulus Prompting",
      "url": "learn/directional-stimulus.html",
      "category": "strategies",
      "useCases": [
        "writing",
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "directional stimulus",
        "dsp",
        "guided generation",
        "hints",
        "cues",
        "steering"
      ],
      "bestFor": "Directional Stimulus Prompting: Use targeted hints and cues to steer LLM outputs toward desired directions."
    },
    {
      "id": "emotion-prompting",
      "name": "Emotion",
      "fullName": "Emotion Prompting",
      "url": "learn/emotion-prompting.html",
      "category": "strategies",
      "useCases": [
        "writing",
        "creative"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "emotion",
        "prompting",
        "add",
        "emotional",
        "stakes",
        "urgency",
        "psychological",
        "framing",
        "prompts",
        "activate",
        "thorough",
        "higher-quality"
      ],
      "bestFor": "Emotion Prompting: Add emotional stakes, urgency, or psychological framing to prompts to activate more thorough, higher-quality AI responses."
    },
    {
      "id": "flipped-interaction",
      "name": "Flipped Interaction",
      "fullName": "Flipped Interaction Method",
      "url": "learn/flipped-interaction.html",
      "category": "strategies",
      "useCases": [
        "research",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "flipped interaction",
        "interview",
        "questions first",
        "personalized",
        "clarification"
      ],
      "bestFor": "Let AI interview you first. Prevent generic advice by having AI ask clarifying questions before responding."
    },
    {
      "id": "generated-knowledge",
      "name": "Generated Knowledge",
      "fullName": "Generated Knowledge Prompting",
      "url": "learn/generated-knowledge.html",
      "category": "strategies",
      "useCases": [
        "research",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "generated knowledge",
        "knowledge generation",
        "two-step",
        "commonsense reasoning",
        "self-generated context"
      ],
      "bestFor": "Generated Knowledge Prompting: Model generates relevant knowledge before answering to improve accuracy."
    },
    {
      "id": "hyde",
      "name": "HyDE (Hypothetical Document Embeddings)",
      "fullName": "HyDE (Hypothetical Document Embeddings)",
      "url": "learn/hyde.html",
      "category": "strategies",
      "useCases": [
        "research"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "hyde",
        "hypothetical document embeddings",
        "retrieval",
        "rag",
        "query expansion",
        "embedding"
      ],
      "bestFor": "HyDE: Generate hypothetical answer documents to improve retrieval without task-specific training."
    },
    {
      "id": "instruction-induction",
      "name": "Instruction Induction",
      "fullName": "Instruction Induction",
      "url": "learn/instruction-induction.html",
      "category": "strategies",
      "useCases": [
        "coding",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "instruction induction",
        "meta-learning",
        "reverse engineering",
        "task inference",
        "demonstrations"
      ],
      "bestFor": "Instruction Induction: Infer task instructions from a few input-output demonstrations automatically."
    },
    {
      "id": "lats",
      "name": "LATS (Language Agent Tree Search)",
      "fullName": "LATS (Language Agent Tree Search)",
      "url": "learn/lats.html",
      "category": "strategies",
      "useCases": [
        "planning",
        "coding"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "lats",
        "language agent tree search",
        "mcts",
        "agent planning",
        "react",
        "tree search"
      ],
      "bestFor": "LATS: Synergize reasoning, acting, and planning via Monte Carlo Tree Search for agents."
    },
    {
      "id": "mipro",
      "name": "MIPRO",
      "fullName": "MIPRO",
      "url": "learn/mipro.html",
      "category": "strategies",
      "useCases": [
        "coding",
        "structured-output"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "mipro",
        "multi-prompt optimization",
        "instruction proposal",
        "bayesian optimization",
        "trace-grounded",
        "bootstrap",
        "per-stage instructions",
        "dspy optimizer",
        "automatic tuning",
        "framework"
      ],
      "bestFor": "MIPRO: Multi-prompt Instruction Proposal Optimizer that uses bootstrapped traces and Bayesian search to find optimal per-stage instructions for LM programs."
    },
    {
      "id": "meta-prompting",
      "name": "Meta",
      "fullName": "Meta Prompting",
      "url": "learn/meta-prompting.html",
      "category": "strategies",
      "useCases": [
        "problem-solving",
        "planning"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "meta prompting",
        "structural templates",
        "meta-level",
        "task approach",
        "thinking structure"
      ],
      "bestFor": "Meta Prompting: High-level structural templates that teach HOW to approach tasks rather than providing specific content."
    },
    {
      "id": "opro",
      "name": "OPRO (Optimization by Prompting)",
      "fullName": "OPRO (Optimization by Prompting)",
      "url": "learn/opro.html",
      "category": "strategies",
      "useCases": [
        "math",
        "coding"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "opro",
        "optimization by prompting",
        "prompt optimization",
        "natural language optimization",
        "deepmind"
      ],
      "bestFor": "OPRO: Use LLMs as optimizers where the optimization task is described in natural language."
    },
    {
      "id": "prompt-chaining",
      "name": "Prompt Chaining",
      "fullName": "Prompt Chaining Framework",
      "url": "learn/prompt-chaining.html",
      "category": "strategies",
      "useCases": [
        "planning",
        "writing",
        "coding"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "prompt chaining",
        "workflow",
        "pipeline",
        "sequential",
        "multi-step",
        "framework"
      ],
      "bestFor": "Break complex tasks into sequential prompts where each builds on previous outputs. Essential for complex workflows."
    },
    {
      "id": "prompt-paraphrasing",
      "name": "Prompt Paraphrasing",
      "fullName": "Prompt Paraphrasing",
      "url": "learn/prompt-paraphrasing.html",
      "category": "strategies",
      "useCases": [
        "writing",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "prompt paraphrasing",
        "ensembling",
        "variants",
        "wording sensitivity",
        "back-translation"
      ],
      "bestFor": "Prompt Paraphrasing: Generate multiple semantically similar prompt variants and ensemble their responses."
    },
    {
      "id": "prompt-repetition",
      "name": "Prompt Repetition",
      "fullName": "Prompt Repetition",
      "url": "learn/prompt-repetition.html",
      "category": "strategies",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "prompt repetition",
        "emphasis",
        "instruction reinforcement",
        "re2",
        "repeated instructions"
      ],
      "bestFor": "Prompt Repetition: Repeating key instructions improves non-reasoning LLM performance through emphasis effects."
    },
    {
      "id": "re2",
      "name": "RE2 (Re-Reading)",
      "fullName": "RE2 (Re-Reading)",
      "url": "learn/re2.html",
      "category": "strategies",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "re-reading",
        "simple",
        "effective",
        "technique",
        "includes",
        "question",
        "twice",
        "prompt",
        "deeper",
        "comprehension",
        "accurate",
        "responses"
      ],
      "bestFor": "RE2 (Re-Reading): A simple yet effective technique that includes the question twice in the prompt for deeper comprehension and more accurate AI responses."
    },
    {
      "id": "react",
      "name": "ReAct",
      "fullName": "ReAct Method",
      "url": "learn/react.html",
      "category": "strategies",
      "useCases": [
        "problem-solving",
        "research",
        "planning"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "react",
        "method",
        "reasoning",
        "acting",
        "step by step",
        "transparent thinking"
      ],
      "bestFor": "Reasoning + Acting. For complex tasks requiring transparent, verifiable thinking processes. AI shows its work."
    },
    {
      "id": "reasoning-via-planning",
      "name": "Reasoning via Planning (RAP)",
      "fullName": "Reasoning via Planning (RAP)",
      "url": "learn/reasoning-via-planning.html",
      "category": "strategies",
      "useCases": [
        "planning",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "reasoning via planning",
        "rap",
        "mcts",
        "monte carlo tree search",
        "world model",
        "planning"
      ],
      "bestFor": "Reasoning via Planning: Treat reasoning as planning using the LLM as both world model and agent with MCTS."
    },
    {
      "id": "rar",
      "name": "Rephrase and Respond (RaR)",
      "fullName": "Rephrase and Respond (RaR)",
      "url": "learn/rar.html",
      "category": "strategies",
      "useCases": [
        "problem-solving",
        "math"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "rephrase",
        "respond",
        "rar",
        "question",
        "answering",
        "surface",
        "ambiguities",
        "improve",
        "comprehension",
        "produce",
        "accurate",
        "responses"
      ],
      "bestFor": "Rephrase and Respond (RaR): Have AI rephrase your question before answering to surface ambiguities, improve comprehension, and produce more accurate responses."
    },
    {
      "id": "rag",
      "name": "Retrieval-Augmented Generation (RAG)",
      "fullName": "Retrieval-Augmented Generation (RAG)",
      "url": "learn/rag.html",
      "category": "strategies",
      "useCases": [
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "rag",
        "retrieval-augmented generation",
        "retrieval",
        "knowledge base",
        "vector search",
        "semantic search",
        "grounding",
        "hallucination reduction",
        "citations",
        "enterprise ai",
        "document retrieval",
        "factual accuracy",
        "framework"
      ],
      "bestFor": "Retrieval-Augmented Generation (RAG): Ground AI responses in real, retrieved documents to reduce hallucination and deliver accurate, source-backed answers."
    },
    {
      "id": "role-prompting",
      "name": "Role Prompting",
      "fullName": "Role Prompting Framework",
      "url": "learn/role-prompting.html",
      "category": "strategies",
      "useCases": [
        "writing",
        "creative"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "role prompting",
        "persona",
        "expert",
        "character",
        "act as",
        "framework"
      ],
      "bestFor": "Assign AI a specific role or persona to shape its responses. Useful for expert knowledge and consistent tone."
    },
    {
      "id": "self-ask",
      "name": "Self-Ask",
      "fullName": "Self-Ask Prompting",
      "url": "learn/self-ask.html",
      "category": "strategies",
      "useCases": [
        "research",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "self-ask",
        "prompting",
        "decompose",
        "complex",
        "questions",
        "explicitly",
        "asking",
        "answering",
        "intermediate",
        "sub-questions",
        "transparent",
        "multi-hop"
      ],
      "bestFor": "Self-Ask Prompting: Have AI decompose complex questions by explicitly asking and answering intermediate sub-questions for transparent multi-hop reasoning."
    },
    {
      "id": "simtom",
      "name": "SimToM",
      "fullName": "SimToM",
      "url": "learn/simtom.html",
      "category": "strategies",
      "useCases": [
        "writing",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "simtom",
        "simulate",
        "theory",
        "mind",
        "filtering",
        "context",
        "person",
        "perspective",
        "answer",
        "questions",
        "based",
        "specific"
      ],
      "bestFor": "SimToM: Simulate Theory of Mind by filtering context to each person's perspective — answer questions based on what specific individuals know, not everything you know."
    },
    {
      "id": "socratic-prompting",
      "name": "Socratic",
      "fullName": "Socratic Prompting",
      "url": "learn/socratic-prompting.html",
      "category": "strategies",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "socratic prompting",
        "socratic method",
        "questioning",
        "iterative reasoning",
        "conversational",
        "probing"
      ],
      "bestFor": "Socratic Prompting: Use reflective Socratic questioning to guide AI through iterative reasoning and discovery."
    },
    {
      "id": "style-prompting",
      "name": "Style",
      "fullName": "Style Prompting",
      "url": "learn/style-prompting.html",
      "category": "strategies",
      "useCases": [
        "writing",
        "creative"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "style",
        "prompting",
        "control",
        "tone",
        "formality",
        "writing",
        "voice",
        "outputs",
        "explicit",
        "instructions",
        "separate",
        "content"
      ],
      "bestFor": "Style Prompting: Control the tone, formality, and writing voice of AI outputs through explicit style instructions that separate content from delivery."
    },
    {
      "id": "system-prompting",
      "name": "System",
      "fullName": "System Prompting",
      "url": "learn/system-prompting.html",
      "category": "strategies",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": null,
      "keywords": [
        "system prompting",
        "system prompt",
        "configuration",
        "behavioral rules",
        "role definition",
        "constraints",
        "instructions",
        "persona",
        "guardrails",
        "safety",
        "output format",
        "production ai"
      ],
      "bestFor": "System Prompting: Define AI behavior, personality, and constraints through structured system-level instructions that shape every response in a conversation."
    },
    {
      "id": "s2a",
      "name": "System 2 Attention (S2A)",
      "fullName": "System 2 Attention (S2A)",
      "url": "learn/s2a.html",
      "category": "strategies",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "system",
        "attention",
        "filter",
        "distracting",
        "biasing",
        "information",
        "context",
        "reasoning",
        "objective",
        "focused",
        "responses",
        "prompting"
      ],
      "bestFor": "System 2 Attention (S2A): Filter distracting or biasing information from context before reasoning for more objective, focused AI responses."
    },
    {
      "id": "chain-of-code",
      "name": "Chain of Code",
      "fullName": "Chain of Code",
      "url": "learn/chain-of-code.html",
      "category": "code",
      "useCases": [
        "coding",
        "math"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "chain of code",
        "coc",
        "code reasoning",
        "lmulator",
        "code execution",
        "semantic reasoning"
      ],
      "bestFor": "Chain of Code: Interweave code execution with LM simulation for reasoning across executable and semantic tasks."
    },
    {
      "id": "modality/code/code-prompting",
      "name": "Code",
      "fullName": "Code Prompting",
      "url": "learn/modality/code/code-prompting.html",
      "category": "code",
      "useCases": [
        "coding"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "code",
        "prompting",
        "strategies",
        "effective",
        "generation",
        "explanation",
        "transformation",
        "review",
        "using",
        "language",
        "models"
      ],
      "bestFor": "Code Prompting: Strategies for effective code generation, explanation, transformation, and review using AI language models."
    },
    {
      "id": "modality/code/code-explanation",
      "name": "Code Explanation",
      "fullName": "Code Explanation",
      "url": "learn/modality/code/code-explanation.html",
      "category": "code",
      "useCases": [
        "coding"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "code explanation",
        "code analysis",
        "code understanding",
        "code walkthrough",
        "code documentation",
        "code interpretation",
        "code review",
        "code comprehension"
      ],
      "bestFor": "Techniques for prompting AI models to analyze, interpret, and explain existing code at multiple levels of abstraction."
    },
    {
      "id": "modality/code/code-review",
      "name": "Code Review",
      "fullName": "Code Review Prompting",
      "url": "learn/modality/code/code-review.html",
      "category": "code",
      "useCases": [
        "coding"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "code review",
        "code quality",
        "security review",
        "performance review",
        "bug detection",
        "code standards",
        "pull request review",
        "static analysis"
      ],
      "bestFor": "Techniques for guiding AI models to perform systematic code reviews covering security, performance, and maintainability."
    },
    {
      "id": "lmql",
      "name": "LMQL (Language Model Query Language)",
      "fullName": "LMQL (Language Model Query Language)",
      "url": "learn/lmql.html",
      "category": "code",
      "useCases": [
        "coding",
        "structured-output"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "lmql",
        "language model query language",
        "constraints",
        "structured output",
        "query language"
      ],
      "bestFor": "LMQL: SQL-like query language for structured, constrained interaction with language models."
    },
    {
      "id": "pal",
      "name": "PAL (Program-Aided Language Models)",
      "fullName": "PAL (Program-Aided Language Models)",
      "url": "learn/pal.html",
      "category": "code",
      "useCases": [
        "coding",
        "math"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "pal",
        "program-aided language models",
        "python",
        "code reasoning",
        "interpreter",
        "arithmetic"
      ],
      "bestFor": "PAL: Generate Python programs as reasoning steps and offload execution to an interpreter for accuracy."
    },
    {
      "id": "modality/code/program-synthesis",
      "name": "Program Synthesis",
      "fullName": "Program Synthesis",
      "url": "learn/modality/code/program-synthesis.html",
      "category": "code",
      "useCases": [
        "coding"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "program synthesis",
        "code generation",
        "specification",
        "input-output examples",
        "automated programming",
        "functional programs",
        "AI programming",
        "code synthesis"
      ],
      "bestFor": "Techniques for guiding AI models to generate complete, functional programs from high-level specifications and input-output examples."
    },
    {
      "id": "modality/code/sql-generation",
      "name": "SQL Generation",
      "fullName": "SQL Generation",
      "url": "learn/modality/code/sql-generation.html",
      "category": "code",
      "useCases": [
        "coding",
        "structured-output"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "SQL generation",
        "text-to-SQL",
        "database queries",
        "natural language to SQL",
        "query optimization",
        "database schema",
        "SQL prompting",
        "data retrieval"
      ],
      "bestFor": "Techniques for prompting AI models to translate natural language questions into accurate, optimized SQL queries."
    },
    {
      "id": "modality/code/self-debugging",
      "name": "Self-Debugging",
      "fullName": "Self-Debugging",
      "url": "learn/modality/code/self-debugging.html",
      "category": "code",
      "useCases": [
        "coding"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "self-debugging",
        "ai-assisted",
        "bug",
        "identification",
        "fixing",
        "strategies",
        "generated",
        "existing",
        "code"
      ],
      "bestFor": "Self-Debugging: AI-assisted bug identification and fixing strategies for generated or existing code."
    },
    {
      "id": "modality/code/structured-output",
      "name": "Structured Output",
      "fullName": "Structured Output",
      "url": "learn/modality/code/structured-output.html",
      "category": "code",
      "useCases": [
        "coding",
        "structured-output"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "structured",
        "output",
        "techniques",
        "generating",
        "reliable",
        "json",
        "xml",
        "yaml",
        "data",
        "formats",
        "language",
        "models"
      ],
      "bestFor": "Structured Output: Techniques for generating reliable JSON, XML, YAML, and other data formats from AI language models."
    },
    {
      "id": "modality/code/test-generation",
      "name": "Test Generation",
      "fullName": "Test Generation",
      "url": "learn/modality/code/test-generation.html",
      "category": "code",
      "useCases": [
        "coding"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "code",
      "keywords": [
        "test generation",
        "unit testing",
        "integration testing",
        "test suites",
        "edge cases",
        "test-driven development",
        "automated testing",
        "code coverage"
      ],
      "bestFor": "Techniques for prompting AI models to create comprehensive test suites including unit tests, integration tests, and edge case coverage."
    },
    {
      "id": "constitutional-ai",
      "name": "Constitutional AI",
      "fullName": "Constitutional AI",
      "url": "learn/constitutional-ai.html",
      "category": "safety",
      "useCases": [
        "writing",
        "research"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "constitutional ai",
        "cai",
        "rlaif",
        "alignment",
        "principles",
        "self-critique",
        "anthropic"
      ],
      "bestFor": "Constitutional AI: Use a set of principles to guide AI self-critique and revision without human feedback."
    },
    {
      "id": "dpo",
      "name": "DPO (Direct Preference Optimization)",
      "fullName": "DPO (Direct Preference Optimization)",
      "url": "learn/dpo.html",
      "category": "safety",
      "useCases": [
        "writing"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": null,
      "keywords": [
        "dpo",
        "direct preference optimization",
        "alignment",
        "rlhf",
        "preference data",
        "fine-tuning"
      ],
      "bestFor": "DPO: Simpler alternative to RLHF that directly optimizes model policy from preference data."
    },
    {
      "id": "instruction-hierarchy",
      "name": "Instruction Hierarchy",
      "fullName": "Instruction Hierarchy",
      "url": "learn/instruction-hierarchy.html",
      "category": "safety",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": null,
      "keywords": [
        "instruction hierarchy",
        "prompt injection",
        "safety",
        "priority levels",
        "system instructions"
      ],
      "bestFor": "Instruction Hierarchy: Define priority levels for conflicting instructions to prevent prompt injection."
    },
    {
      "id": "ape-framework",
      "name": "APE Framework (Action, Purpose, Expectation)",
      "fullName": "APE Framework (Action, Purpose, Expectation)",
      "url": "learn/ape-framework.html",
      "category": "community",
      "useCases": [
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "ape framework",
        "action",
        "purpose",
        "expectation",
        "beginner",
        "community framework"
      ],
      "bestFor": "APE Framework: Beginner-friendly three-part framework for quick, clear prompts."
    },
    {
      "id": "bab",
      "name": "BAB",
      "fullName": "BAB Framework",
      "url": "learn/bab.html",
      "category": "community",
      "useCases": [
        "writing",
        "creative"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "bab",
        "before",
        "after",
        "bridge",
        "narrative",
        "copywriting",
        "community framework"
      ],
      "bestFor": "BAB: Narrative framework describing current state, desired state, and solution path."
    },
    {
      "id": "bore",
      "name": "BORE",
      "fullName": "BORE Framework",
      "url": "learn/bore.html",
      "category": "community",
      "useCases": [
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "bore",
        "background",
        "objective",
        "role",
        "expectation",
        "community framework"
      ],
      "bestFor": "BORE: Four-component framework emphasizing background context and measurable expectations."
    },
    {
      "id": "broke",
      "name": "BROKE",
      "fullName": "BROKE Framework",
      "url": "learn/broke.html",
      "category": "community",
      "useCases": [
        "writing",
        "problem-solving"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "broke",
        "background",
        "role",
        "objective",
        "key result",
        "expectation",
        "okr",
        "community framework"
      ],
      "bestFor": "BROKE: Five-component framework combining OKR methodology with prompt engineering."
    },
    {
      "id": "cape",
      "name": "CAPE",
      "fullName": "CAPE Framework",
      "url": "learn/cape.html",
      "category": "community",
      "useCases": [
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "cape",
        "context",
        "action",
        "parameters",
        "end goal",
        "educational",
        "community framework"
      ],
      "bestFor": "CAPE: Educational framework integrating chain-of-thought into structured prompting."
    },
    {
      "id": "care",
      "name": "CARE",
      "fullName": "CARE Framework",
      "url": "learn/care.html",
      "category": "community",
      "useCases": [
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "care",
        "context",
        "action",
        "role",
        "expectation",
        "nielsen norman",
        "community framework"
      ],
      "bestFor": "CARE: Context-aware framework from Nielsen Norman Group with role assignment and expected outcomes."
    },
    {
      "id": "create",
      "name": "CREATE",
      "fullName": "CREATE Framework",
      "url": "learn/create.html",
      "category": "community",
      "useCases": [
        "writing",
        "creative"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "create",
        "character",
        "request",
        "examples",
        "adjustments",
        "type of output",
        "extras",
        "community framework"
      ],
      "bestFor": "CREATE: Six-component framework with persona adoption, examples, and iterative adjustments."
    },
    {
      "id": "era",
      "name": "ERA",
      "fullName": "ERA Framework",
      "url": "learn/era.html",
      "category": "community",
      "useCases": [
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "era",
        "expectation",
        "role",
        "action",
        "outcome-first",
        "community framework"
      ],
      "bestFor": "ERA: Three-element framework prioritizing expected outcomes before role and action."
    },
    {
      "id": "grade",
      "name": "GRADE",
      "fullName": "GRADE Framework",
      "url": "learn/grade.html",
      "category": "community",
      "useCases": [
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "grade",
        "goal",
        "request",
        "action",
        "details",
        "example",
        "community framework"
      ],
      "bestFor": "GRADE: Five-element framework ensuring clear objectives with illustrative examples."
    },
    {
      "id": "icio",
      "name": "ICIO",
      "fullName": "ICIO Framework",
      "url": "learn/icio.html",
      "category": "community",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "icio",
        "instruction",
        "context",
        "input data",
        "output indicator",
        "community framework"
      ],
      "bestFor": "ICIO: Four-part framework emphasizing clear data input and output specification."
    },
    {
      "id": "master-prompt",
      "name": "MASTER Prompt",
      "fullName": "MASTER Prompt Method",
      "url": "learn/master-prompt.html",
      "category": "community",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "intermediate",
      "type": "framework",
      "modality": null,
      "keywords": [
        "master",
        "living document",
        "meta-framework",
        "organizational context",
        "community framework"
      ],
      "bestFor": "MASTER: Living document meta-framework providing comprehensive organizational context to AI."
    },
    {
      "id": "race",
      "name": "RACE",
      "fullName": "RACE Framework",
      "url": "learn/race.html",
      "category": "community",
      "useCases": [
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "race",
        "role",
        "action",
        "context",
        "expected output",
        "community framework"
      ],
      "bestFor": "RACE: Four-component framework defining role, task, context, and expected output format."
    },
    {
      "id": "risen",
      "name": "RISEN",
      "fullName": "RISEN Framework",
      "url": "learn/risen.html",
      "category": "community",
      "useCases": [
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "risen",
        "role",
        "instructions",
        "steps",
        "end goal",
        "narrowing",
        "community framework"
      ],
      "bestFor": "RISEN: Five-component framework with built-in step sequencing and scope narrowing."
    },
    {
      "id": "rodes",
      "name": "RODES",
      "fullName": "RODES Framework",
      "url": "learn/rodes.html",
      "category": "community",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "rodes",
        "role",
        "objective",
        "details",
        "examples",
        "sense check",
        "community framework"
      ],
      "bestFor": "RODES: Five-part framework with built-in output validation through sense checking."
    },
    {
      "id": "roses",
      "name": "ROSES",
      "fullName": "ROSES Framework",
      "url": "learn/roses.html",
      "category": "community",
      "useCases": [
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "roses",
        "role",
        "objective",
        "scenario",
        "expected solution",
        "steps",
        "community framework"
      ],
      "bestFor": "ROSES: Five-component framework emphasizing scenario context and step-by-step guidance."
    },
    {
      "id": "rtf",
      "name": "RTF",
      "fullName": "RTF Framework",
      "url": "learn/rtf.html",
      "category": "community",
      "useCases": [
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "rtf",
        "role",
        "task",
        "format",
        "minimalist",
        "community framework"
      ],
      "bestFor": "RTF: Minimalist three-part framework for persona, task, and output format."
    },
    {
      "id": "scope",
      "name": "SCOPE",
      "fullName": "SCOPE Framework",
      "url": "learn/scope.html",
      "category": "community",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "scope",
        "self-optimizing",
        "agent",
        "prompt evolution",
        "automated optimization",
        "community framework"
      ],
      "bestFor": "SCOPE: Self-optimizing agent prompt evolution framework for autonomous refinement."
    },
    {
      "id": "smart-prompting",
      "name": "SMART Prompting",
      "fullName": "SMART Prompting Framework",
      "url": "learn/smart-prompting.html",
      "category": "community",
      "useCases": [
        "writing",
        "planning"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "smart",
        "specific",
        "measurable",
        "achievable",
        "relevant",
        "time-bound",
        "community framework"
      ],
      "bestFor": "SMART: Goal-setting framework adapted for AI prompting from project management methodology."
    },
    {
      "id": "spark",
      "name": "SPARK",
      "fullName": "SPARK Framework",
      "url": "learn/spark.html",
      "category": "community",
      "useCases": [
        "creative",
        "writing"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "spark",
        "situation",
        "problem",
        "aspiration",
        "result",
        "kismet",
        "community framework"
      ],
      "bestFor": "SPARK: Narrative-driven framework for creative problem-solving with a serendipity element."
    },
    {
      "id": "tag",
      "name": "TAG",
      "fullName": "TAG Framework",
      "url": "learn/tag.html",
      "category": "community",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "tag",
        "task",
        "action",
        "goal",
        "goal-oriented",
        "community framework"
      ],
      "bestFor": "TAG: Goal-oriented three-element framework clarifying what, how, and why."
    },
    {
      "id": "trace",
      "name": "TRACE",
      "fullName": "TRACE Framework",
      "url": "learn/trace.html",
      "category": "community",
      "useCases": [
        "writing",
        "planning"
      ],
      "complexity": "beginner",
      "type": "framework",
      "modality": null,
      "keywords": [
        "trace",
        "task",
        "request",
        "action",
        "context",
        "example",
        "community framework"
      ],
      "bestFor": "TRACE: Five-component framework with task clarity and contextual grounding."
    },
    {
      "id": "modality/image/composition-prompting",
      "name": "Composition",
      "fullName": "Composition Prompting",
      "url": "learn/modality/image/composition-prompting.html",
      "category": "image",
      "useCases": [
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "composition",
        "framing",
        "rule of thirds",
        "camera angle",
        "depth of field",
        "visual hierarchy",
        "spatial arrangement"
      ],
      "bestFor": "Control the spatial arrangement, framing, and visual hierarchy of AI-generated images through structured compositional instructions."
    },
    {
      "id": "modality/image/controlnet-prompting",
      "name": "ControlNet",
      "fullName": "ControlNet Prompting",
      "url": "learn/modality/image/controlnet-prompting.html",
      "category": "image",
      "useCases": [
        "creative"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "ControlNet",
        "spatial conditioning",
        "edge maps",
        "depth maps",
        "pose skeleton",
        "structural control",
        "guided generation"
      ],
      "bestFor": "Use structural conditioning inputs like edge maps, depth maps, and pose skeletons to precisely control AI image generation beyond text prompts alone."
    },
    {
      "id": "modality/image/image-gen-prompting",
      "name": "Image Generation",
      "fullName": "Image Generation Prompting",
      "url": "learn/modality/image/image-gen-prompting.html",
      "category": "image",
      "useCases": [
        "creative"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "image generation",
        "text-to-image",
        "DALL-E",
        "Stable Diffusion",
        "Midjourney",
        "prompt crafting",
        "style modifiers",
        "quality terms"
      ],
      "bestFor": "Master the art of crafting text prompts that produce high-quality, accurate AI-generated images through structured description techniques."
    },
    {
      "id": "modality/image/image-prompting",
      "name": "Image Prompting Basics",
      "fullName": "Image Prompting Basics",
      "url": "learn/modality/image/image-prompting.html",
      "category": "image",
      "useCases": [
        "creative"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "image prompting",
        "multimodal",
        "vision",
        "visual understanding",
        "image analysis",
        "image description",
        "visual input",
        "multimodal AI"
      ],
      "bestFor": "Foundational techniques for prompting AI models to understand, analyze, describe, and reason about images in multimodal contexts."
    },
    {
      "id": "modality/image/image-as-text",
      "name": "Image-as-Text",
      "fullName": "Image-as-Text Prompting",
      "url": "learn/modality/image/image-as-text.html",
      "category": "image",
      "useCases": [
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "image-as-text",
        "visual description",
        "text conversion",
        "captioning",
        "OCR",
        "accessibility",
        "structured description"
      ],
      "bestFor": "Convert visual information into structured text descriptions to enable text-only models to reason about image content effectively."
    },
    {
      "id": "modality/image/image-to-image",
      "name": "Image-to-Image",
      "fullName": "Image-to-Image Prompting",
      "url": "learn/modality/image/image-to-image.html",
      "category": "image",
      "useCases": [
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "image-to-image",
        "img2img",
        "image transformation",
        "denoising strength",
        "reference image",
        "style conversion",
        "sketch to render"
      ],
      "bestFor": "Transform existing images using AI by combining reference images with text prompts to control style, content, and transformation strength."
    },
    {
      "id": "modality/image/inpainting-prompting",
      "name": "Inpainting",
      "fullName": "Inpainting Prompting",
      "url": "learn/modality/image/inpainting-prompting.html",
      "category": "image",
      "useCases": [
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "inpainting",
        "image editing",
        "region replacement",
        "object removal",
        "image restoration",
        "selective editing",
        "mask-based editing"
      ],
      "bestFor": "Guide AI to selectively edit, replace, or restore specific regions within existing images while preserving surrounding context."
    },
    {
      "id": "modality/image/multimodal-cot",
      "name": "Multimodal Chain of Thought",
      "fullName": "Multimodal Chain of Thought",
      "url": "learn/modality/image/multimodal-cot.html",
      "category": "image",
      "useCases": [
        "math",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "multimodal cot",
        "visual reasoning",
        "chain-of-thought",
        "image reasoning",
        "rationale generation",
        "vision-language",
        "two-stage reasoning"
      ],
      "bestFor": "Extend chain-of-thought reasoning to combine visual and textual information, generating rationales that incorporate both modalities before producing answers."
    },
    {
      "id": "modality/image/negative-prompting",
      "name": "Negative",
      "fullName": "Negative Prompting",
      "url": "learn/modality/image/negative-prompting.html",
      "category": "image",
      "useCases": [
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "negative prompt",
        "exclusion",
        "artifact avoidance",
        "quality improvement",
        "CFG scale",
        "classifier-free guidance",
        "image quality"
      ],
      "bestFor": "Specify what to exclude from AI-generated images to improve quality, avoid artifacts, and control output more precisely."
    },
    {
      "id": "modality/image/style-transfer",
      "name": "Style Transfer",
      "fullName": "Style Transfer Prompting",
      "url": "learn/modality/image/style-transfer.html",
      "category": "image",
      "useCases": [
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "style transfer",
        "artistic style",
        "visual aesthetics",
        "medium",
        "painting style",
        "art direction",
        "prompt-based styling"
      ],
      "bestFor": "Apply artistic styles, visual aesthetics, and design languages to AI-generated or existing images through carefully crafted prompts."
    },
    {
      "id": "modality/image/visual-cot",
      "name": "Visual Chain of Thought",
      "fullName": "Visual Chain of Thought",
      "url": "learn/modality/image/visual-cot.html",
      "category": "image",
      "useCases": [
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "visual cot",
        "spatial reasoning",
        "region analysis",
        "visual decomposition",
        "image regions",
        "sequential visual analysis"
      ],
      "bestFor": "Guide AI models through step-by-step visual reasoning by explicitly referencing and analyzing image regions in sequence."
    },
    {
      "id": "modality/image/vqa",
      "name": "Visual Question Answering",
      "fullName": "Visual Question Answering",
      "url": "learn/modality/image/vqa.html",
      "category": "image",
      "useCases": [
        "research",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "image",
      "keywords": [
        "VQA",
        "visual question answering",
        "image questions",
        "visual grounding",
        "counting",
        "spatial relationships",
        "attribute recognition"
      ],
      "bestFor": "Techniques for asking precise questions about images and getting accurate, grounded answers from multimodal AI models."
    },
    {
      "id": "modality/audio/audio-classification",
      "name": "Audio Classification",
      "fullName": "Audio Classification",
      "url": "learn/modality/audio/audio-classification.html",
      "category": "audio",
      "useCases": [
        "structured-output",
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "audio",
      "keywords": [
        "audio classification",
        "genre detection",
        "emotion recognition",
        "speaker identification",
        "environment detection",
        "event detection",
        "audio categorization",
        "sound analysis"
      ],
      "bestFor": "Prompt-based techniques for categorizing audio by genre, emotion, speaker identity, environment, and event detection."
    },
    {
      "id": "modality/audio/audio-prompting",
      "name": "Audio Prompting Basics",
      "fullName": "Audio Prompting Basics",
      "url": "learn/modality/audio/audio-prompting.html",
      "category": "audio",
      "useCases": [
        "creative"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": "audio",
      "keywords": [
        "audio prompting",
        "multimodal",
        "audio understanding",
        "audio analysis",
        "transcription",
        "audio reasoning",
        "audio input",
        "multimodal AI"
      ],
      "bestFor": "Foundational techniques for guiding AI models to understand, transcribe, analyze, and reason about audio inputs."
    },
    {
      "id": "modality/audio/music-gen",
      "name": "Music Generation",
      "fullName": "Music Generation Prompting",
      "url": "learn/modality/audio/music-gen.html",
      "category": "audio",
      "useCases": [
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "audio",
      "keywords": [
        "music generation",
        "audio composition",
        "musical intent",
        "AI music",
        "sound generation",
        "melody",
        "rhythm",
        "prompt-to-music"
      ],
      "bestFor": "Techniques for translating musical intent into natural language prompts that AI models use to generate audio compositions."
    },
    {
      "id": "modality/audio/stt-prompting",
      "name": "Speech-to-Text",
      "fullName": "Speech-to-Text Prompting",
      "url": "learn/modality/audio/stt-prompting.html",
      "category": "audio",
      "useCases": [
        "structured-output"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "audio",
      "keywords": [
        "speech-to-text",
        "transcription",
        "speaker attribution",
        "domain vocabulary",
        "structured text",
        "speech recognition",
        "formatted output",
        "audio transcription"
      ],
      "bestFor": "Techniques for controlling how speech is transcribed into structured, formatted text with speaker attribution and domain vocabulary."
    },
    {
      "id": "modality/audio/tts-prompting",
      "name": "Text-to-Speech",
      "fullName": "Text-to-Speech Prompting",
      "url": "learn/modality/audio/tts-prompting.html",
      "category": "audio",
      "useCases": [
        "creative",
        "writing"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "audio",
      "keywords": [
        "text-to-speech",
        "voice synthesis",
        "speaking style",
        "emotion",
        "pacing",
        "pronunciation",
        "speech generation",
        "voice control"
      ],
      "bestFor": "Methods for controlling voice synthesis including speaking style, emotion, pacing, and pronunciation through text instructions."
    },
    {
      "id": "modality/audio/voice-cloning",
      "name": "Voice Cloning",
      "fullName": "Voice Cloning Prompting",
      "url": "learn/modality/audio/voice-cloning.html",
      "category": "audio",
      "useCases": [
        "creative"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": "audio",
      "keywords": [
        "voice cloning",
        "reference audio",
        "voice reproduction",
        "speaker characteristics",
        "voice synthesis",
        "voice matching",
        "audio cloning",
        "voice transfer"
      ],
      "bestFor": "Methods for combining reference audio with text instructions to reproduce specific voice characteristics for new content."
    },
    {
      "id": "modality/video/temporal-reasoning",
      "name": "Temporal Reasoning",
      "fullName": "Temporal Reasoning",
      "url": "learn/modality/video/temporal-reasoning.html",
      "category": "video",
      "useCases": [
        "problem-solving",
        "research"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "video",
      "keywords": [
        "temporal reasoning",
        "time sequence",
        "event ordering",
        "causal reasoning",
        "temporal analysis",
        "video timeline",
        "sequence understanding",
        "temporal logic"
      ],
      "bestFor": "Techniques for prompting AI models to understand, analyze, and reason about events across time in video content."
    },
    {
      "id": "modality/video/video-captioning",
      "name": "Video Captioning",
      "fullName": "Video Captioning",
      "url": "learn/modality/video/video-captioning.html",
      "category": "video",
      "useCases": [
        "writing",
        "structured-output"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "video",
      "keywords": [
        "video captioning",
        "video description",
        "caption generation",
        "video accessibility",
        "subtitle generation",
        "video narration",
        "audio description",
        "video text"
      ],
      "bestFor": "Techniques for prompting AI models to generate accurate, descriptive captions and text descriptions for video content."
    },
    {
      "id": "modality/video/video-editing",
      "name": "Video Editing",
      "fullName": "Video Editing Prompting",
      "url": "learn/modality/video/video-editing.html",
      "category": "video",
      "useCases": [
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "video",
      "keywords": [
        "video editing",
        "AI editing",
        "video transformation",
        "video modification",
        "clip editing",
        "video enhancement",
        "prompt-based editing",
        "video post-production"
      ],
      "bestFor": "Techniques for using AI to modify, transform, and enhance existing video content through natural language instructions."
    },
    {
      "id": "modality/video/video-gen",
      "name": "Video Generation",
      "fullName": "Video Generation Prompting",
      "url": "learn/modality/video/video-gen.html",
      "category": "video",
      "useCases": [
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "video",
      "keywords": [
        "video generation",
        "text-to-video",
        "video synthesis",
        "motion generation",
        "video creation",
        "AI video",
        "Sora",
        "Runway"
      ],
      "bestFor": "Techniques for crafting prompts that guide AI models to create, synthesize, and produce video content from textual descriptions."
    },
    {
      "id": "modality/video/video-prompting",
      "name": "Video Prompting Basics",
      "fullName": "Video Prompting Basics",
      "url": "learn/modality/video/video-prompting.html",
      "category": "video",
      "useCases": [
        "creative"
      ],
      "complexity": "beginner",
      "type": "technique",
      "modality": "video",
      "keywords": [
        "video prompting",
        "multimodal",
        "video understanding",
        "video analysis",
        "temporal",
        "motion",
        "video input",
        "multimodal AI"
      ],
      "bestFor": "Foundational techniques for guiding AI models to analyze, understand, and reason about video content including temporal sequences and motion."
    },
    {
      "id": "modality/video/video-qa",
      "name": "Video QA",
      "fullName": "Video QA",
      "url": "learn/modality/video/video-qa.html",
      "category": "video",
      "useCases": [
        "research",
        "problem-solving"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "video",
      "keywords": [
        "video question answering",
        "video QA",
        "visual question",
        "video comprehension",
        "video understanding",
        "multimodal QA",
        "video queries",
        "temporal QA"
      ],
      "bestFor": "Techniques for prompting AI models to answer specific questions about video content, combining visual understanding with temporal reasoning."
    },
    {
      "id": "modality/3d/3d-model-gen",
      "name": "3D Model Generation",
      "fullName": "3D Model Generation",
      "url": "learn/modality/3d/3d-model-gen.html",
      "category": "3d",
      "useCases": [
        "creative"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": "3d",
      "keywords": [
        "3D generation",
        "text-to-3D",
        "mesh generation",
        "3D modeling",
        "DreamFusion",
        "Shap-E",
        "neural radiance",
        "3D objects"
      ],
      "bestFor": "Techniques for prompting AI systems to create three-dimensional models, meshes, and objects from text descriptions."
    },
    {
      "id": "modality/3d/3d-prompting",
      "name": "3D Prompting Basics",
      "fullName": "3D Prompting Basics",
      "url": "learn/modality/3d/3d-prompting.html",
      "category": "3d",
      "useCases": [
        "creative"
      ],
      "complexity": "intermediate",
      "type": "technique",
      "modality": "3d",
      "keywords": [
        "3D prompting",
        "spatial",
        "three-dimensional",
        "3D understanding",
        "mesh",
        "point cloud",
        "spatial reasoning",
        "multimodal 3D"
      ],
      "bestFor": "Foundational techniques for guiding AI models to understand, generate, and reason about three-dimensional spatial data."
    },
    {
      "id": "modality/3d/point-cloud",
      "name": "Point Cloud",
      "fullName": "Point Cloud Prompting",
      "url": "learn/modality/3d/point-cloud.html",
      "category": "3d",
      "useCases": [
        "structured-output",
        "research"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": "3d",
      "keywords": [
        "point cloud",
        "LiDAR",
        "depth sensor",
        "3D scanning",
        "photogrammetry",
        "spatial data",
        "3D reconstruction",
        "PointNet"
      ],
      "bestFor": "Techniques for guiding AI models to process, analyze, and reason about 3D point cloud data from LiDAR and depth sensors."
    },
    {
      "id": "modality/3d/pose-estimation",
      "name": "Pose Estimation",
      "fullName": "Pose Estimation Prompting",
      "url": "learn/modality/3d/pose-estimation.html",
      "category": "3d",
      "useCases": [
        "structured-output"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": "3d",
      "keywords": [
        "pose estimation",
        "body pose",
        "skeletal tracking",
        "human pose",
        "joint detection",
        "body analysis",
        "movement analysis",
        "biomechanics"
      ],
      "bestFor": "Techniques for guiding AI models to detect, analyze, and reason about human body poses and skeletal configurations."
    },
    {
      "id": "modality/3d/scene-understanding",
      "name": "Scene Understanding",
      "fullName": "Scene Understanding",
      "url": "learn/modality/3d/scene-understanding.html",
      "category": "3d",
      "useCases": [
        "research",
        "problem-solving"
      ],
      "complexity": "advanced",
      "type": "technique",
      "modality": "3d",
      "keywords": [
        "scene understanding",
        "spatial relationships",
        "room layout",
        "3D scene",
        "object placement",
        "environment analysis",
        "spatial reasoning",
        "scene graph"
      ],
      "bestFor": "Techniques for prompting AI to analyze complete 3D scenes including spatial relationships, object placement, and environmental context."
    }
  ]
}